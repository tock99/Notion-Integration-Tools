<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Qiita / note / はてな トレンド</title>
<style>
  :root{
    --qiita:#55C500; --note:#41C9B4; --hatena:#008FDE;
    --ink:#111; --muted:#666; --bg:#fff; --chip:#f4f8ef; --border:#e6f3d8; --card:#fff; --err:#b00020;
    --title-fs:14px; --title-lh:1.4; --badge-fs:11px; --badge-lh:1.2;
  }
  html,body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Noto Sans JP",sans-serif}
  /* ページのスクロールバーを非表示（スクロール自体は可能） */
  body{-ms-overflow-style:none; scrollbar-width:none;}
  body::-webkit-scrollbar{display:none;}

  .shell{max-width:1200px;margin:0 auto;padding:12px}
  .grid{display:grid;gap:12px}
  @media (min-width: 880px){ .grid.cols-2{grid-template-columns:1fr 1fr} }
  @media (min-width: 1080px){ .grid.cols-3{grid-template-columns:1fr 1fr 1fr} }

  .panel{border:1px solid var(--border);border-radius:10px;padding:10px;background:var(--card)}
  .head{display:flex;align-items:center;gap:10px;margin-bottom:6px}
  .head .spacer{flex:1}
  .head h3{margin:0;font-size:16px;font-weight:700}
  .meta{font-size:12px;color:var(--muted)}
  .ctrls{display:flex;gap:6px}
  .btn{
    font-size:10px; height:20px; line-height:18px; padding:0 8px;
    border:1px solid var(--border); border-radius:999px; background:#fff; cursor:pointer; color:inherit;
  }
  .btn:hover{filter:brightness(0.98)}
  .btn.active{background:var(--chip);}

  ol.list{list-style:none;margin:8px 0 0;padding:0;display:grid;gap:8px}
  .item a{
    display:flex;gap:10px;text-decoration:none;color:inherit;
    border:1px solid var(--border);border-radius:8px;padding:8px 10px;background:#fff;
    /* ▼ 縦幅を固定（タイトル2行 + バッジ1行 + 余白を想定） */
    min-height: calc((var(--title-fs) * var(--title-lh) * 2) + (var(--badge-fs) * var(--badge-lh)) + 0px);
  }
  .rank{width:24px;min-width:24px;height:24px;display:grid;place-items:center;border-radius:6px;background:var(--chip);font-weight:700;font-size:12px}

  /* タイトル：常に2行に固定し、はみ出しは省略。タイトルだけホバーで下線 */
  .title{
    font-weight:600;font-size:var(--title-fs);line-height:var(--title-lh);
    display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;
    overflow:hidden;height:calc(var(--title-fs) * var(--title-lh) * 2);
  }
  .title:hover{text-decoration:underline}

  /* バッジは1行で省略（高さを揃える） */
  .badges{
    margin-top:4px;display:flex;flex-wrap:nowrap;gap:6px;
    font-size:var(--badge-fs);line-height:var(--badge-lh);color:var(--muted);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }
  .chip{display:inline-flex;align-items:center;gap:4px;padding:1px 6px;border-radius:999px;background:var(--chip);border:1px solid var(--border)}
  .chip svg{width:12px;height:12px}

  .status{margin-top:6px;font-size:12px;color:var(--muted)}
  .error{color:var(--err)}
  .debug{margin-top:8px;font-size:11px;color:#888;white-space:pre-wrap}
</style>

<div class="shell" id="shell">
  <div id="layout" class="grid"></div>
</div>

<script>
(async () => {
  /* ===== 0) Query & const ===== */
  const q = new URLSearchParams(location.search);
  const SOURCE = (q.get("source") || "all").toLowerCase(); // all|qiita|note|hatena
  const MAX = Math.max(1, Math.min(20, Number(q.get("max") || 5)));
  const PROXY_BASE = q.get("proxy_base") || ""; // 例: https://your-worker.workers.dev
  const DEBUG = (q.get("debug") || "0") === "1";

  const NOTE_SOURCE = (q.get("note_source") || "json").toLowerCase(); // json|html
  const HATENA_MODE = (q.get("hatena_mode") || "auto").toLowerCase(); // auto|proxy|direct
  const HATENA_CAT  = (q.get("hatena_cat")  || "general").toLowerCase(); // general|it（初期表示）

  // Qiita
  const QIITA_FEED = "https://qiita.com/popular-items/feed.atom";
  const QIITA_ITEM_API = id => `https://qiita.com/api/v2/items/${encodeURIComponent(id)}`;

  // はてブ（注目 / IT）
  const HATENA_RSS_1 = "https://b.hatena.ne.jp/hotentry.rss";
  const HATENA_RSS_2 = "https://b.hatena.ne.jp/hotentry?mode=rss";
  const HATENA_IT_1  = "https://b.hatena.ne.jp/hotentry/it.rss";
  const HATENA_IT_2  = "https://b.hatena.ne.jp/hotentry/it?mode=rss";

  // note Worker endpoints
  const NOTE_TODAY_JSON = (max) => `${PROXY_BASE}/note/today.json?max=${encodeURIComponent(max)}`;
  const NOTE_TODAY_HTML = (max) => `${PROXY_BASE}/note/today.html?max=${encodeURIComponent(max)}`;

  // note 直接スクレイプ
  const NOTE_TODAY_URL = "https://note.com/today";
  const NOTE_DETAIL_API = key => `https://note.com/api/v3/notes/${encodeURIComponent(key)}`;

  /* ===== 1) Layout ===== */
  const layout = document.getElementById("layout");
  const shell  = document.getElementById("shell");
  const wantQiita  = SOURCE === "all" || SOURCE === "qiita";
  const wantNote   = SOURCE === "all" || SOURCE === "note";
  const wantHatena = SOURCE === "all" || SOURCE === "hatena";

  const activeCount = [wantQiita, wantNote, wantHatena].filter(Boolean).length;
  if (activeCount === 3) layout.classList.add("cols-3");
  else if (activeCount === 2) layout.classList.add("cols-2");

  /* 各カラム +30px： shell の max-width を列数×30px 広げる */
  const baseWidth = 1200;
  shell.style.maxWidth = `calc(${baseWidth}px + ${activeCount*30}px)`;

  const qiitaDOM  = wantQiita  ? makePanel("Qiita", "--qiita")          : null;
  const noteDOM   = wantNote   ? makePanel("note", "--note")            : null;
  const hatenaDOM = wantHatena ? makePanel("はてな", "--hatena", true)  : null;
  if (qiitaDOM)  layout.appendChild(qiitaDOM.wrap);
  if (noteDOM)   layout.appendChild(noteDOM.wrap);
  if (hatenaDOM) layout.appendChild(hatenaDOM.wrap);

  /* ===== 2) Run ===== */
  if (qiitaDOM)  runQiita(qiitaDOM).catch(()=>{});
  if (noteDOM)   runNoteToday(noteDOM).catch(()=>{});
  if (hatenaDOM){
    setupHatenaControls(hatenaDOM);
    runHatena(hatenaDOM, HATENA_CAT).catch(()=>{});
  }

  /* ===== helpers: UI/NET ===== */
  function makePanel(title, brandVar, withCtrls=false){
    const wrap = document.createElement("div");
    wrap.className = "col";
    wrap.innerHTML = `
      <div class="panel">
        <div class="head">
          <h3 style="color:${css(brandVar)}">${title}</h3>
          <div class="meta">更新情報を取得中…</div>
          <div class="spacer"></div>
          <div class="ctrls" style="display:${withCtrls?'flex':'none'}"></div>
        </div>
        <ol class="list"></ol>
        <div class="status">読み込み中…</div>
        <div class="debug" style="display:${DEBUG?'block':'none'}"></div>
      </div>
    `;
    return {
      wrap,
      meta: wrap.querySelector(".meta"),
      list: wrap.querySelector(".list"),
      status: wrap.querySelector(".status"),
      debug: wrap.querySelector(".debug"),
      ctrls: wrap.querySelector(".ctrls"),
      brand: css(brandVar)
    };
  }
  function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function heart(){ return `<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 21s-7.2-4.35-9.6-8.7C.6 8.9 2.2 5 6 5c2.1 0 3.4 1.2 4 2 0.6-0.8 1.9-2 4-2 3.8 0 5.4 3.9 3.6 7.3C19.2 16.65 12 21 12 21z"/></svg>`; }
  function tagIcon(){ return `<svg viewBox="0 0 24 24"><path fill="currentColor" d="M10.59 2L3 9.59V21h11.41L22 13.41V2H10.59zM7 12a2 2 0 110-4 2 2 0 010 4z"/></svg>`; }
  function escapeHtml(s){ return (s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&gt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function pad2(n){ return n<10 ? "0"+n : ""+n; }
  function fmtMDHM(input){
    const d = (input instanceof Date) ? input : new Date(input);
    if (isNaN(d.getTime())) return ""; // パース不可は空 → 呼び出し側で「取得不可」
    return `${pad2(d.getMonth()+1)}/${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
  }
  function addRow(listEl, rank, href, title, likeText, tagText, brandColor){
    const li = document.createElement("li");
    li.className = "item";
    li.innerHTML = `
      <a href="${href}" target="_blank" rel="noopener">
        <div class="rank" style="color:${brandColor}">${rank}</div>
        <div class="col">
          <div class="title">${escapeHtml(title)}</div>
          <div class="badges">
            <span class="chip">${heart()} <span>${likeText}</span></span>
            <span class="chip">${tagIcon()} <span>${tagText}</span></span>
          </div>
        </div>
      </a>`;
    listEl.appendChild(li);
    return li;
  }
  function updateRow(li, likeText, tagText){
    const chips = li.querySelectorAll(".chip span:last-child");
    if (chips[0]) chips[0].textContent = likeText;
    if (chips[1]) chips[1].textContent = tagText;
  }
  async function proxyFetch(target, { accept } = {}){
    if (!PROXY_BASE) throw new Error("proxy_base not configured");
    const u = `${PROXY_BASE}/?url=${encodeURIComponent(target)}`;
    const r = await fetch(u, { headers: accept ? { "Accept": accept } : {} });
    if (!r.ok) throw new Error(`proxy http ${r.status}`);
    return r;
  }

  /* ===== Qiita ===== */
  function parseQiitaAtom(xmlText){
    const doc = new DOMParser().parseFromString(xmlText,"application/xml");
    const feedUpdated = doc.querySelector("feed > updated")?.textContent || "";
    const entries = [...doc.querySelectorAll("entry")].map(e=>{
      const title = e.querySelector("title")?.textContent?.trim() || "(no title)";
      const link = e.querySelector('link[rel="alternate"]')?.getAttribute("href") || e.querySelector("link")?.getAttribute("href") || "";
      const m = link.match(/\/items\/([0-9a-f]{20,})/i);
      const itemId = m ? m[1] : null;
      return { title, link, itemId };
    });
    return { feedUpdated, entries };
  }
  async function runQiita(dom){
    const dbg = [];
    try{
      const feed = await proxyFetch(QIITA_FEED, { accept:"application/atom+xml" });
      dbg.push(`qiita feed status=${feed.status}`);
      const xml = await feed.text();
      const {feedUpdated, entries} = parseQiitaAtom(xml);
      dom.meta.textContent = feedUpdated
        ? "RSS更新: " + fmtMDHM(feedUpdated)
        : "RSS更新: 取得不可";

      dom.list.innerHTML=""; dom.status.textContent="記事詳細を取得中…";
      let rank=1;
      for (const ent of entries.slice(0,MAX)){
        const li = addRow(dom.list, rank, ent.link, ent.title, "いいね: 取得中", "タグ: 取得中", dom.brand);
        if (ent.itemId){
          try{
            const r = await proxyFetch(QIITA_ITEM_API(ent.itemId), { accept: "application/json" });
            dbg.push(`qiita item ${ent.itemId} status=${r.status}`);
            const j = await r.json();
            const likes = (typeof j.likes_count==="number")? j.likes_count : "—";
            const tags  = Array.isArray(j.tags)? j.tags.map(t=>t.name) : [];
            const shown = tags.slice(0,2).join(", "); const rest = tags.length>2? ` 他:${tags.length-2}`:"";
            updateRow(li, `いいね: ${likes}`, tags.length?`タグ: ${shown}${rest}`:"タグ: —");
          }catch(e){ updateRow(li,"いいね: —","タグ: —"); dbg.push(`qiita item error: ${String(e).slice(0,120)}`); }
        }
        rank++;
      }
      dom.status.textContent = "";
    }catch(e){
      dom.status.classList.add("error");
      dom.status.textContent = "取得に失敗しました。";
      dbg.push(`qiita error: ${String(e).slice(0,200)}`);
    }
    if (DEBUG) dom.debug.textContent = dbg.join("\n");
  }

  /* ===== note 今日の注目（Worker + フォールバック） ===== */
  async function noteFromWorkerJSON(max, dbg){
    try{
      const r = await fetch(NOTE_TODAY_JSON(max), { headers: { "Accept": "application/json" } });
      dbg.push(`note today.json status=${r.status}`);
      if (!r.ok) return null;
      const j = await r.json().catch(()=>null);
      if (!j || !Array.isArray(j.items) || j.items.length===0) return null;
      return j.items.map(x=>({
        url: x.url, title: x.title, likes: Number(x.likes)||0, tags: Array.isArray(x.tags)?x.tags:[]
      }));
    }catch(e){ dbg.push(`note json err: ${String(e)}`); return null; }
  }
  async function noteFromWorkerHTML(max, dbg){
    try{
      const r = await fetch(NOTE_TODAY_HTML(max), { headers: { "Accept": "text/html" } });
      dbg.push(`note today.html status=${r.status}`);
      if (!r.ok) return null;
      const html = await r.text();
      const doc = new DOMParser().parseFromString(html, "text/html");
      const lis = [...doc.querySelectorAll("ol > li")];
      dbg.push(`note today.html li=${lis.length}`);
      if (lis.length===0) return null;
      return lis.slice(0,max).map(li=>{
        const a = li.querySelector("a");
        const strong = a?.querySelector("strong");
        const small = a?.querySelector("small");
        const href = a?.getAttribute("href") || "#";
        const title = (strong?.textContent || a?.textContent || "").trim() || "(no title)";
        const metaTxt = (small?.textContent || "").trim();
        const likeMatch = metaTxt.match(/スキ:\s*([0-9]+)/);
        const likes = likeMatch ? Number(likeMatch[1]) : 0;
        let tags = [];
        const tagMatch = metaTxt.match(/タグ:\s*(.+)$/);
        if (tagMatch) {
          const raw = tagMatch[1].trim();
          if (raw !== "—") tags = raw.split(",").map(s=>s.trim()).filter(Boolean);
        }
        return { url: href, title, likes, tags };
      });
    }catch(e){ dbg.push(`note html err: ${String(e)}`); return null; }
  }

  function extractPairsFromHtml(html, limit=60){
    const out=[], seen=new Set(); let m;
    const reHref=/href="\/([^"\/@]+)\/n\/([a-z0-9]{8,})"/ig;
    while((m=reHref.exec(html))!==null){ const urlname=m[1], key=m[2]; if(!seen.has(key)){seen.add(key); out.push({urlname,key}); if(out.length>=limit) break;} }
    if(out.length<5){
      const reKey=/"key"\s*:\s*"([a-z0-9]+)"/ig;
      while((m=reKey.exec(html))!==null){ const key=m[1]; if(!seen.has(key)){seen.add(key); out.push({urlname:"",key}); if(out.length>=limit) break;} }
    }
    return out;
  }
  async function noteDetailByKey(key, dbg){
    try{
      const r = await proxyFetch(NOTE_DETAIL_API(key), { accept:"application/json" });
      dbg && dbg.push(`detail ${key} status=${r.status}`);
      const j = await r.json().catch(()=>null);
      const d = j?.data || {};
      const urlname = d?.user?.urlname || d?.user?.urlName || d?.creator?.urlname || d?.creator?.urlName || "";
      return {
        url: urlname ? `https://note.com/${urlname}/n/${key}` : `https://note.com/n/${key}`,
        title: (d?.name || "").trim() || "(no title)",
        likes: Number(d?.likedCount ?? d?.likeCount ?? 0) || 0,
        tags: Array.isArray(d?.hashtags)? d.hashtags.map(h=>h.name).filter(Boolean) : []
      };
    }catch(e){ dbg && dbg.push(`detail ${key} err: ${String(e)}`); return null; }
  }
  async function noteFromClientScrape(max, dbg){
    try{
      const r = await proxyFetch(NOTE_TODAY_URL, { accept:"text/html" });
      dbg.push(`today html status=${r.status}`);
      const html = await r.text();
      const pairs = extractPairsFromHtml(html, Math.max(50, max*6));
      dbg.push(`today pairs=${pairs.length}`);
      const items = [];
      for (const {key} of pairs){
        const d = await noteDetailByKey(key, dbg);
        if (d) items.push(d);
        if (items.length >= max) break;
      }
      return items.length?items:null;
    }catch(e){ dbg.push(`today scrape err: ${String(e)}`); return null; }
  }

  async function runNoteToday(dom){
    const dbg = [];
    try{
      if (!PROXY_BASE){
        dom.status.classList.add("error");
        dom.status.textContent = "proxy_base 未設定";
        if (DEBUG) dom.debug.textContent = "note today needs proxy_base";
        return;
      }
      dom.meta.textContent = "取得: " + fmtMDHM(new Date());
      dom.list.innerHTML=""; dom.status.textContent="記事を収集中…";

      // 1) Worker 優先
      let items = NOTE_SOURCE==="json"
        ? await noteFromWorkerJSON(MAX, dbg)
        : await noteFromWorkerHTML(MAX, dbg);

      // 2) もう片方でも試す
      if (!items) {
        items = NOTE_SOURCE==="json"
          ? await noteFromWorkerHTML(MAX, dbg)
          : await noteFromWorkerJSON(MAX, dbg);
      }
      // 3) クライアント側スクレイプ
      if (!items) items = await noteFromClientScrape(MAX, dbg);

      // 表示
      let rank=1;
      for (const it of (items||[]).slice(0,MAX)){
        const tags = it.tags || [];
        const tShown = tags.slice(0,2).join(", ");
        const tRest  = tags.length>2 ? ` 他:${tags.length-2}` : "";
        addRow(dom.list, rank, it.url, it.title,
               `スキ: ${Number.isFinite(it.likes)?it.likes:0}`,
               tags.length?`タグ: ${tShown}${tRest}`:"タグ: —",
               dom.brand);
        rank++;
      }
      dom.status.textContent = dom.list.children.length ? "" : "記事が見つかりませんでした。";
    }catch(e){
      dom.status.classList.add("error");
      dom.status.textContent = "取得に失敗しました。";
      dbg.push(`note today fatal: ${String(e).slice(0,200)}`);
    }
    if (DEBUG) dom.debug.textContent = dbg.join("\n");
  }

  /* ===== はてな（トグル + 日付フォールバック） ===== */
  function parseHatenaRSS(xml){
    const doc = new DOMParser().parseFromString(xml,"application/xml");
    const NS_HATENA = "http://www.hatena.ne.jp/info/xmlns#";
    const NS_DC     = "http://purl.org/dc/elements/1.1/";

    const ch = doc.getElementsByTagName("channel")[0];
    let lastBuild =
      ch?.getElementsByTagName("lastBuildDate")[0]?.textContent?.trim() ||
      ch?.getElementsByTagName("pubDate")[0]?.textContent?.trim() || "";

    const items = [...doc.getElementsByTagName("item")].map(n=>{
      const title = n.getElementsByTagName("title")[0]?.textContent?.trim() || "(no title)";
      const link  = n.getElementsByTagName("link")[0]?.textContent?.trim()  || "";
      let bc = NaN;
      const bcSel = n.querySelector('hatena\\:bookmarkcount');
      if (bcSel) bc = Number(bcSel.textContent);
      if (!Number.isFinite(bc)) {
        const bcNs = n.getElementsByTagNameNS(NS_HATENA, "bookmarkcount")[0];
        if (bcNs) bc = Number(bcNs.textContent);
      }
      if (!Number.isFinite(bc)) bc = 0;
      const tags = [];
      const cats = n.getElementsByTagName("category");
      for (let i=0;i<cats.length;i++){ const t = cats[i].textContent.trim(); if (t) tags.push(t); }
      const dcSubs = n.getElementsByTagNameNS(NS_DC, "subject");
      for (let i=0;i<dcSubs.length;i++){ const t = dcSubs[i].textContent.trim(); if (t) tags.push(t); }
      const itemPub = n.getElementsByTagName("pubDate")[0]?.textContent?.trim() || "";
      const itemDc  = n.getElementsByTagNameNS(NS_DC, "date")[0]?.textContent?.trim() || "";
      return { title, link, bookmarks: bc, tags, _pub: itemPub || itemDc };
    });

    if (!lastBuild) {
      let bestTs = -1, bestRaw = "";
      for (const it of items){
        const ts = Date.parse(it._pub);
        if (!Number.isNaN(ts) && ts > bestTs){ bestTs = ts; bestRaw = it._pub; }
      }
      if (bestRaw) lastBuild = bestRaw;
    }
    for (const it of items) delete it._pub;
    return { lastBuild, items };
  }

  function hatenaFeedsFor(category){
    if (category === "it") return [HATENA_IT_1, HATENA_IT_2];
    return [HATENA_RSS_1, HATENA_RSS_2];
  }

  async function runHatena(dom, category="general"){
    const dbg = [];
    try{
      dom.list.innerHTML="";
      dom.status.textContent = "読み込み中…";
      const [RSS1, RSS2] = hatenaFeedsFor(category);

      let xml = null;

      // 1) 直取り
      if (HATENA_MODE === "auto" || HATENA_MODE === "direct") {
        try {
          const r1 = await fetch(RSS1, { headers: { Accept: "application/xml" } });
          if (!r1.ok) throw new Error("direct #1 " + r1.status);
          xml = await r1.text(); dbg.push(`hatena(${category}) direct #1 ok`);
        } catch(e1){
          try {
            const r2 = await fetch(RSS2, { headers: { Accept: "application/xml" } });
            if (!r2.ok) throw new Error("direct #2 " + r2.status);
            xml = await r2.text(); dbg.push(`hatena(${category}) direct #2 ok`);
          } catch(e2){
            dbg.push(`hatena(${category}) direct failed: ` + e2);
            if (HATENA_MODE === "direct") throw e2;
          }
        }
      }

      // 2) プロキシ
      if (!xml && (HATENA_MODE === "auto" || HATENA_MODE === "proxy")) {
        if (!PROXY_BASE) throw new Error("proxy_base not configured for hatena");
        let p = await proxyFetch(RSS1, { accept: "application/rss+xml,application/xml;q=0.9,*/*;q=0.7" });
        dbg.push(`hatena(${category}) proxy #1 status=${p.status}`);
        if (!p.ok) {
          p = await proxyFetch(RSS2, { accept: "application/rss+xml,application/xml;q=0.9,*/*;q=0.7" });
          dbg.push(`hatena(${category}) proxy #2 status=${p.status}`);
          if (!p.ok) throw new Error(`hatena(${category}) proxy failed (${p.status})`);
        }
        xml = await p.text();
      }

      const { lastBuild, items } = parseHatenaRSS(xml);
      dom.meta.textContent = lastBuild
        ? "RSS更新: " + (fmtMDHM(lastBuild) || "取得不可")
        : "RSS更新: 取得不可";

      const top = items.sort((a,b)=> (b.bookmarks||0) - (a.bookmarks||0)).slice(0,MAX);

      dom.list.innerHTML="";
      let rank=1;
      for (const it of top){
        const tags = it.tags || [];
        const tShown = tags.slice(0,2).join(", ");
        const tRest  = tags.length>2 ? ` 他:${tags.length-2}` : "";
        addRow(dom.list, rank, it.link, it.title,
               `ブクマ: ${Number.isFinite(it.bookmarks)?it.bookmarks:0}`,
               tags.length?`タグ: ${tShown}${tRest}`:"タグ: —",
               dom.brand);
        rank++;
      }
      dom.status.textContent = top.length ? "" : "記事が見つかりませんでした。";
    }catch(e){
      dom.status.classList.add("error");
      dom.status.textContent = "取得に失敗しました。";
      dbg.push(`hatena(${category}) error: ${String(e).slice(0,200)}`);
    }
    if (DEBUG) dom.debug.textContent = dbg.join("\n");
  }

  /* ===== はてな：右上トグル（小型） ===== */
  function setupHatenaControls(dom){
    const ctrls = dom.ctrls;
    if (!ctrls) return;

    const btnGeneral = document.createElement("button");
    btnGeneral.className = "btn";
    btnGeneral.textContent = "注目";
    btnGeneral.style.color = css("--hatena");

    const btnIT = document.createElement("button");
    btnIT.className = "btn";
    btnIT.textContent = "IT";
    btnIT.style.color = css("--hatena");

    ctrls.appendChild(btnGeneral);
    ctrls.appendChild(btnIT);

    let current = (HATENA_CAT === "it") ? "it" : "general";
    setActive(current);

    btnGeneral.addEventListener("click", () => {
      if (current === "general") return;
      current = "general";
      setActive(current);
      runHatena(dom, "general");
    });
    btnIT.addEventListener("click", () => {
      if (current === "it") return;
      current = "it";
      setActive(current);
      runHatena(dom, "it");
    });

    function setActive(cat){
      btnGeneral.classList.toggle("active", cat==="general");
      btnIT.classList.toggle("active", cat==="it");
      btnGeneral.style.borderColor = (cat==="general") ? dom.brand : "var(--border)";
      btnIT.style.borderColor      = (cat==="it")      ? dom.brand : "var(--border)";
    }
  }
})();
</script>
