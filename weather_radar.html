<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RainViewer Radar (Compact, Bottom HUD)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
  html, body, #map { height: 100%; margin: 0; }
  .leaflet-control-attribution { font-size: 10px; }
  .hud {
    position: fixed; left: 50%; bottom: 8px; transform: translateX(-50%);
    z-index: 1000; display: flex; align-items: center; gap: 6px;
    background: #000b; color: #fff; border-radius: 10px; padding: 4px 6px;
    font: 11px/1.2 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
      "Hiragino Sans", "Noto Sans JP", sans-serif;
    backdrop-filter: blur(3px);
  }
  .hud button {
    cursor: pointer; border: 0; border-radius: 8px; padding: 2px 6px;
    background: #fff1; color: #fff; font-size: 11px;
  }
  .hud button:hover { background: #fff2; }
  .hud input[type="range"] { width: 160px; height: 12px; }
  .sep { opacity: 0.5; }
  .hidden { display: none !important; }
</style>

<div id="map"></div>

<!-- ‰∏ãÈÉ®„ÉªÊ•µÂ∞èHUDÔºà„Ç¢„Ç§„Ç≥„É≥ÔºãÊôÇÂàª„ÅÆ„ÅøÔºâ -->
<div class="hud" id="hud" aria-label="Radar controls">
  <button id="play" title="ÂÜçÁîü/‰∏ÄÊôÇÂÅúÊ≠¢">‚ñ∂</button>
  <span class="sep">|</span>
  <input id="slider" type="range" min="0" max="0" step="1" value="0" aria-label="„Éï„É¨„Éº„É†"/>
  <span class="sep">|</span>
  <button id="locate" title="ÁèæÂú®Âú∞„Å∏">üìç</button>
  <span id="time" style="opacity: 0.85"></span>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  // ======== URL „Éë„É©„É°„Éº„ÇøÂá¶ÁêÜ ========
  const params = new URLSearchParams(location.search);

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

  function getNum(name, def, min = -Infinity, max = Infinity) {
    const v = params.get(name);
    if (v === null) return def;
    const n = Number(v);
    return Number.isFinite(n) ? clamp(n, min, max) : def;
  }
  function getBool(name, def) {
    const v = params.get(name);
    if (v === null) return def;
    return v === "1" || v.toLowerCase() === "true";
  }
  function getStr(name, def) {
    const v = params.get(name);
    return v === null ? def : v;
  }

  // View Ë®≠ÂÆö
  let ll = null;
  if (params.get("ll")) {
    const [latStr, lonStr] = params.get("ll").split(",");
    const lat = Number(latStr), lon = Number(lonStr);
    if (Number.isFinite(lat) && Number.isFinite(lon)) ll = [lat, lon];
  } else if (params.get("lat") && params.get("lon")) {
    const lat = Number(params.get("lat")), lon = Number(params.get("lon"));
    if (Number.isFinite(lat) && Number.isFinite(lon)) ll = [lat, lon];
  }
  const zoom = getNum("z", 7, 2, 18);

  // bounds=lat1,lon1,lat2,lon2
  let bounds = null;
  if (params.get("bounds")) {
    const a = params.get("bounds").split(",").map(Number);
    if (a.length === 4 && a.every(Number.isFinite)) {
      bounds = [[a[0], a[1]], [a[2], a[3]]];
    }
  }

  const useGeoloc = getBool("geoloc", true);
  const autoplay = getBool("autoplay", false);
  const speed = getNum("speed", 1100, 200, 5000);
  const radarOpacity = getNum("opacity", 0.75, 0, 1);
  const tz = getStr("tz", "Asia/Tokyo"); // "system"„Å™„Çâ„Éñ„É©„Ç¶„Ç∂Ê®ôÊ∫ñ

  // frame=last | number | negative-from-end
  const frameParam = getStr("frame", "last");

  const showHud = getBool("hud", true);
  if (!showHud) document.getElementById("hud").classList.add("hidden");

  // ======== Âú∞Âõ≥ÂàùÊúüÂåñ ========
  const map = L.map("map");
  L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: "¬© OpenStreetMap contributors",
  }).addTo(map);

  let userMarker = null;
  function setUserMarker(latlng) {
    if (userMarker) map.removeLayer(userMarker);
    userMarker = L.marker(latlng).addTo(map);
  }

  // Ë°®Á§∫ÁØÑÂõ≤ÂÑ™ÂÖàÈ†Ü‰Ωç: bounds > ll > geoloc > fallback
  function applyInitialView() {
    if (bounds) {
      map.fitBounds(bounds);
      return;
    }
    if (ll) {
      map.setView(ll, zoom);
      return;
    }
    if (useGeoloc && navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const here = [pos.coords.latitude, pos.coords.longitude];
          setUserMarker(here);
          map.setView(here, 10);
        },
        () => fallback(),
        { enableHighAccuracy: true, timeout: 8000, maximumAge: 300000 }
      );
    } else {
      fallback();
    }
  }
  function fallback() {
    // Èñ¢Ë•øÔΩûÈñ¢Êù±„Åå„Åä„Åä„Çà„ÅùÂèé„Åæ„Çã„Éì„É•„Éº
    map.setView([35.0, 138.0], 7.0);
  }

  // ======== RainViewer „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Âà∂Âæ° ========
  const slider = document.getElementById("slider");
  const timeLabel = document.getElementById("time");
  const playBtn = document.getElementById("play");

  let frames = [], currentLayer = null, idx = 0, playing = false, timer = null;

  function tileUrl(f) {
    // 256px„Çø„Ç§„É´ / color=1 / smooth=1
    return `https://tilecache.rainviewer.com/v2/radar/${f.path}/256/{z}/{x}/{y}/2/1_1.png`;
  }

  function formatTime(unixSec) {
    const d = new Date(unixSec * 1000);
    if (tz && tz !== "system") {
      return d.toLocaleString("ja-JP", { timeZone: tz });
    }
    return d.toLocaleString(); // „Éñ„É©„Ç¶„Ç∂Êó¢ÂÆö
  }

  function showFrame(i) {
    if (!frames.length) return;
    i = ((i % frames.length) + frames.length) % frames.length; // wrap & Ê≠£
    if (currentLayer) map.removeLayer(currentLayer);
    const f = frames[i];
    currentLayer = L.tileLayer(tileUrl(f), { opacity: radarOpacity });
    currentLayer.addTo(map);
    idx = i;
    slider.value = String(i);
    timeLabel.textContent = formatTime(f.time);
  }

  function stepNext() { showFrame(idx + 1); }
  function updatePlayBtn() { playBtn.textContent = playing ? "‚è∏" : "‚ñ∂"; }

  playBtn.onclick = () => {
    if (!frames.length) return;
    playing = !playing;
    if (playing) {
      timer = setInterval(stepNext, speed);
    } else {
      clearInterval(timer);
    }
    updatePlayBtn();
  };

  slider.oninput = () => {
    if (playing) {
      playing = false;
      clearInterval(timer);
      updatePlayBtn();
    }
    showFrame(+slider.value);
  };

  document.getElementById("locate").onclick = () => {
    if (!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const here = [pos.coords.latitude, pos.coords.longitude];
        setUserMarker(here);
        map.setView(here, 10);
      },
      () => {},
      { enableHighAccuracy: true, timeout: 8000, maximumAge: 300000 }
    );
  };

  // ======== Ëµ∑Âãï„Éï„É≠„Éº ========
  applyInitialView();

  fetch("https://api.rainviewer.com/public/weather-maps.json")
    .then((r) => r.json())
    .then((data) => {
      frames = (data.radar?.past || []).concat(data.radar?.nowcast || []);
      if (!frames.length) {
        console.warn("No frames from RainViewer.");
        return;
      }
      slider.max = frames.length - 1;

      // ÂàùÊúü„Éï„É¨„Éº„É†Ê±∫ÂÆö
      let initialIndex = frames.length - 1; // last
      if (frameParam !== "last") {
        const n = Number(frameParam);
        if (Number.isInteger(n)) {
          initialIndex = n >= 0 ? clamp(n, 0, frames.length - 1)
                                : clamp(frames.length + n, 0, frames.length - 1);
        }
      }
      slider.value = String(initialIndex);
      showFrame(initialIndex);

      // Ëá™ÂãïÂÜçÁîü
      if (autoplay) {
        playing = true;
        updatePlayBtn();
        timer = setInterval(stepNext, speed);
      }
    })
    .catch((e) => console.error("RainViewer fetch error", e));
</script>
