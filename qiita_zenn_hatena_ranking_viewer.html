<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Qiita / Zenn / はてな トレンド</title>
<style>
  :root{
    --qiita:#55C500; --zenn:#3EA8FF; --hatena:#008FDE;
    --ink:#111; --muted:#666; --bg:#fff; --chip:#f4f8ef; --border:#e6f3d8; --card:#fff; --err:#b00020;
    --title-fs:14px; --title-lh:1.4; --badge-fs:11px; --badge-lh:1.2;
  }
  html,body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Noto Sans JP",sans-serif}
  body{-ms-overflow-style:none; scrollbar-width:none;}
  body::-webkit-scrollbar{display:none;}

  .shell{max-width:1200px;margin:0 auto;padding:12px}
  .grid{display:grid;gap:15px}
  @media (min-width: 880px){ .grid.cols-2{grid-template-columns:1fr 1fr} }
  @media (min-width: 1080px){ .grid.cols-3{grid-template-columns:1fr 1fr 1fr} }

  .panel{border:1px solid var(--border);border-radius:10px;padding:10px;background:var(--card)}
  .head{display:flex;align-items:center;gap:10px;margin-bottom:6px}
  .head .spacer{flex:1}
  .head h3{margin:0;font-size:18px;font-weight:700}
  .meta{font-size:12px;color:var(--muted)}
  .ctrls{display:flex;gap:6px}
  .btn{
    font-size:10px; height:20px; line-height:18px; padding:0 8px;
    border:1px solid var(--border); border-radius:999px; background:#fff; cursor:pointer; color:inherit;
  }
  .btn:hover{filter:brightness(0.98)}
  .btn.active{background:var(--chip);}

  ol.list{list-style:none;margin:8px 0 0;padding:0;display:grid;gap:8px}
  .item a{
    display:flex;gap:10px;text-decoration:none;color:inherit;
    border:1px solid var(--border);border-radius:8px;padding:8px 10px;background:#fff;
    /* タイトル2行＋バッジ1行の高さに揃える */
    min-height: calc((var(--title-fs) * var(--title-lh) * 2) + (var(--badge-fs) * var(--badge-lh)));
  }
  .rank{width:24px;min-width:24px;height:24px;display:grid;place-items:center;border-radius:6px;background:var(--chip);font-weight:700;font-size:12px}

  .title{
    font-weight:600;font-size:var(--title-fs);line-height:var(--title-lh);
    display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;
    overflow:hidden;height:calc(var(--title-fs) * var(--title-lh) * 2);
  }
  .title:hover{text-decoration:underline}

  .badges{
    margin-top:4px;display:flex;flex-wrap:nowrap;gap:6px;
    font-size:var(--badge-fs);line-height:var(--badge-lh);color:var(--muted);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }
  .chip{display:inline-flex;align-items:center;gap:4px;padding:1px 6px;border-radius:999px;background:var(--chip);border:1px solid var(--border)}
  .chip svg{width:12px;height:12px}

  .status{margin-top:6px;font-size:12px;color:var(--muted)}
  .error{color:var(--err)}
  .debug{margin-top:8px;font-size:11px;color:#888;white-space:pre-wrap}
</style>

<div class="shell" id="shell">
  <div id="layout" class="grid"></div>
</div>

<script>
(async () => {
  /* ===== 0) Query & const ===== */
  const q = new URLSearchParams(location.search);
  const SOURCE = (q.get("source") || "all").toLowerCase(); // all|qiita|zenn|hatena
  const MAX = Math.max(1, Math.min(20, Number(q.get("max") || 5)));
  const PROXY_BASE = q.get("proxy_base") || ""; // 例: https://your-worker.workers.dev
  const DEBUG = (q.get("debug") || "0") === "1";

  // Qiita
  const QIITA_FEED = "https://qiita.com/popular-items/feed.atom";
  const QIITA_ITEM_API = id => `https://qiita.com/api/v2/items/${encodeURIComponent(id)}`;

  // Zenn
  const ZENN_FEED = "https://zenn.dev/feed";

  // はてブ（注目 / IT）
  const HATENA_RSS_1 = "https://b.hatena.ne.jp/hotentry.rss";
  const HATENA_RSS_2 = "https://b.hatena.ne.jp/hotentry?mode=rss";
  const HATENA_IT_1  = "https://b.hatena.ne.jp/hotentry/it.rss";
  const HATENA_IT_2  = "https://b.hatena.ne.jp/hotentry/it?mode=rss";
  const HATENA_MODE = (q.get("hatena_mode") || "auto").toLowerCase(); // auto|proxy|direct
  const HATENA_CAT  = (q.get("hatena_cat")  || "general").toLowerCase(); // general|it

  /* ===== 1) Layout ===== */
  const layout = document.getElementById("layout");
  const shell  = document.getElementById("shell");
  const wantQiita  = SOURCE === "all" || SOURCE === "qiita";
  const wantZenn   = SOURCE === "all" || SOURCE === "zenn";
  const wantHatena = SOURCE === "all" || SOURCE === "hatena";

  const activeCount = [wantQiita, wantZenn, wantHatena].filter(Boolean).length;
  if (activeCount === 3) layout.classList.add("cols-3");
  else if (activeCount === 2) layout.classList.add("cols-2");

  // カラム+30px幅増し（以前の仕様）
  const baseWidth = 1320;
  shell.style.maxWidth = `calc(${baseWidth}px + ${activeCount*30}px)`;

  const qiitaDOM  = wantQiita  ? makePanel("Qiita", "--qiita")          : null;
  const zennDOM   = wantZenn   ? makePanel("Zenn",  "--zenn")           : null;
  const hatenaDOM = wantHatena ? makePanel("はてなブックマーク", "--hatena", true)  : null;
  if (qiitaDOM)  layout.appendChild(qiitaDOM.wrap);
  if (zennDOM)   layout.appendChild(zennDOM.wrap);
  if (hatenaDOM) layout.appendChild(hatenaDOM.wrap);

  /* ===== 2) Run ===== */
  if (qiitaDOM)  runQiita(qiitaDOM).catch(()=>{});
  if (zennDOM)   runZenn(zennDOM).catch(()=>{});
  if (hatenaDOM){
    setupHatenaControls(hatenaDOM);
    runHatena(hatenaDOM, HATENA_CAT).catch(()=>{});
  }

  /* ===== helpers: UI/NET ===== */
  function makePanel(title, brandVar, withCtrls=false){
    const wrap = document.createElement("div");
    wrap.className = "col";
    wrap.innerHTML = `
      <div class="panel">
        <div class="head">
          <h3 style="color:${css(brandVar)}">${title}</h3>
          <div class="meta">更新情報を取得中…</div>
          <div class="spacer"></div>
          <div class="ctrls" style="display:${withCtrls?'flex':'none'}"></div>
        </div>
        <ol class="list"></ol>
        <div class="status">読み込み中…</div>
        <div class="debug" style="display:${DEBUG?'block':'none'}"></div>
      </div>
    `;
    return {
      wrap,
      meta: wrap.querySelector(".meta"),
      list: wrap.querySelector(".list"),
      status: wrap.querySelector(".status"),
      debug: wrap.querySelector(".debug"),
      ctrls: wrap.querySelector(".ctrls"),
      brand: css(brandVar)
    };
  }
  function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function heart(){ return `<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 21s-7.2-4.35-9.6-8.7C.6 8.9 2.2 5 6 5c2.1 0 3.4 1.2 4 2 0.6-0.8 1.9-2 4-2 3.8 0 5.4 3.9 3.6 7.3C19.2 16.65 12 21 12 21z"/></svg>`; }
  function tagIcon(){ return `<svg viewBox="0 0 24 24"><path fill="currentColor" d="M10.59 2L3 9.59V21h11.41L22 13.41V2H10.59zM7 12a2 2 0 110-4 2 2 0 010 4z"/></svg>`; }
  function escapeHtml(s){ return (s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function pad2(n){ return n<10 ? "0"+n : ""+n; }
  function fmtMDHM(input){
    const d = (input instanceof Date) ? input : new Date(input);
    if (isNaN(d.getTime())) return "";
    return `${pad2(d.getMonth()+1)}/${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
  }
  function addRow(listEl, rank, href, title, likeText, tagText, brandColor){
    const li = document.createElement("li");
    li.className = "item";
    li.innerHTML = `
      <a href="${href}" target="_blank" rel="noopener">
        <div class="rank" style="color:${brandColor}">${rank}</div>
        <div class="col">
          <div class="title">${escapeHtml(title)}</div>
          <div class="badges">
            <span class="chip">${heart()} <span>${likeText}</span></span>
            <span class="chip">${tagIcon()} <span>${tagText}</span></span>
          </div>
        </div>
      </a>`;
    listEl.appendChild(li);
    return li;
  }
  function updateRow(li, likeText, tagText){
    const chips = li.querySelectorAll(".chip span:last-child");
    if (chips[0]) chips[0].textContent = likeText;
    if (chips[1]) chips[1].textContent = tagText;
  }
  async function proxyFetch(target, { accept } = {}){
    if (!PROXY_BASE) throw new Error("proxy_base not configured");
    const u = `${PROXY_BASE}/?url=${encodeURIComponent(target)}`;
    const r = await fetch(u, { headers: accept ? { "Accept": accept } : {} });
    if (!r.ok) throw new Error(`proxy http ${r.status}`);
    return r;
  }

  /* ===== Qiita ===== */
  function parseQiitaAtom(xmlText){
    const doc = new DOMParser().parseFromString(xmlText,"application/xml");
    const feedUpdated = doc.querySelector("feed > updated")?.textContent || "";
    const entries = [...doc.querySelectorAll("entry")].map(e=>{
      const title = e.querySelector("title")?.textContent?.trim() || "(no title)";
      const link = e.querySelector('link[rel="alternate"]')?.getAttribute("href") || e.querySelector("link")?.getAttribute("href") || "";
      const m = link.match(/\/items\/([0-9a-f]{20,})/i);
      const itemId = m ? m[1] : null;
      return { title, link, itemId };
    });
    return { feedUpdated, entries };
  }
  async function runQiita(dom){
    const dbg = [];
    try{
      const feed = await proxyFetch(QIITA_FEED, { accept:"application/atom+xml" });
      dbg.push(`qiita feed status=${feed.status}`);
      const xml = await feed.text();
      const {feedUpdated, entries} = parseQiitaAtom(xml);
      dom.meta.textContent = feedUpdated ? "RSS更新: " + fmtMDHM(feedUpdated) : "RSS更新: 取得不可";

      dom.list.innerHTML=""; dom.status.textContent="記事詳細を取得中…";
      let rank=1;
      for (const ent of entries.slice(0,MAX)){
        const li = addRow(dom.list, rank, ent.link, ent.title, "いいね: 取得中", "タグ: 取得中", dom.brand);
        if (ent.itemId){
          try{
            const r = await proxyFetch(QIITA_ITEM_API(ent.itemId), { accept: "application/json" });
            dbg.push(`qiita item ${ent.itemId} status=${r.status}`);
            const j = await r.json();
            const likes = (typeof j.likes_count==="number")? j.likes_count : "—";
            const tags  = Array.isArray(j.tags)? j.tags.map(t=>t.name) : [];
            const shown = tags.slice(0,2).join(", "); const rest = tags.length>2? ` 他:${tags.length-2}`:"";
            updateRow(li, `いいね: ${likes}`, tags.length?`タグ: ${shown}${rest}`:"タグ: —");
          }catch(e){ updateRow(li,"いいね: —","タグ: —"); dbg.push(`qiita item error: ${String(e).slice(0,120)}`); }
        }
        rank++;
      }
      dom.status.textContent = "";
    }catch(e){
      dom.status.classList.add("error");
      dom.status.textContent = "取得に失敗しました。";
      dbg.push(`qiita error: ${String(e).slice(0,200)}`);
    }
    if (DEBUG) dom.debug.textContent = dbg.join("\n");
  }

  /* ===== Zenn ===== */
  function parseZennFeed(xmlText){
    const doc = new DOMParser().parseFromString(xmlText, "application/xml");
    let feedUpdated =
      doc.querySelector("feed > updated")?.textContent?.trim() ||
      doc.querySelector("channel > lastBuildDate")?.textContent?.trim() ||
      doc.querySelector("channel > pubDate")?.textContent?.trim() || "";

    let nodes = [...doc.querySelectorAll("feed > entry")];
    const isAtom = nodes.length > 0;
    if (!nodes.length) nodes = [...doc.querySelectorAll("channel > item")];

    const items = nodes.map(n=>{
      const title = n.querySelector("title")?.textContent?.trim() || "(no title)";
      let link = "";
      if (isAtom) {
        link = n.querySelector('link[rel="alternate"]')?.getAttribute("href")
            || n.querySelector("link")?.getAttribute("href") || "";
      } else {
        link = n.querySelector("link")?.textContent?.trim() || "";
      }
      const tags = isAtom
        ? [...n.querySelectorAll("category")].map(c=>c.getAttribute("term")).filter(Boolean)
        : [...n.querySelectorAll("category")].map(c=>c.textContent.trim()).filter(Boolean);
      return { title, link, tags };
    });

    return { feedUpdated, items };
  }

  // Zenn記事ページを1件だけ解析して「タグ」と「いいね数」を可能な限り取得
  async function enrichZennFromPage(url, dbg){
    try{
      const r = await proxyFetch(url, { accept:"text/html" });
      dbg.push(`zenn page ${url} status=${r.status}`);
      const html = await r.text();
      const doc = new DOMParser().parseFromString(html, "text/html");

      // 1) タグ収集
      const tags = new Set();
      // <meta property="article:tag" content="xxx">
      doc.querySelectorAll('meta[property="article:tag"]').forEach(m=>{
        const t = (m.getAttribute("content")||"").trim(); if (t) tags.add(t);
      });
      // /topics/ リンク
      doc.querySelectorAll('a[href^="/topics/"]').forEach(a=>{
        const t=(a.textContent||"").trim(); if (t) tags.add(t);
      });
      // JSON-LD keywords/about
      const ld = [...doc.querySelectorAll('script[type="application/ld+json"]')].map(s=>s.textContent).join("\n");
      if (ld) {
        try{
          const j = JSON.parse(ld);
          const list = Array.isArray(j) ? j : [j];
          for (const obj of list){
            const kw = obj?.keywords;
            if (typeof kw === "string") kw.split(",").forEach(s=>{ const t=s.trim(); if (t) tags.add(t); });
            else if (Array.isArray(kw)) kw.forEach(s=>{ const t=String(s).trim(); if (t) tags.add(t); });
            const about = obj?.about;
            if (Array.isArray(about)) about.forEach(x=>{ const t = (x?.name||"").trim(); if (t) tags.add(t); });
          }
        }catch{}
      }

      // 2) いいね数（__NEXT_DATA__ など）
      let likes = null;
      const next = doc.querySelector('#__NEXT_DATA__')?.textContent || "";
      function scanLikes(obj){
        let best = null;
        try{
          const stack=[obj];
          while(stack.length){
            const cur = stack.pop();
            if (!cur || typeof cur!=='object') continue;
            for (const [k,v] of Object.entries(cur)){
              if (typeof v === 'number' && /like/i.test(k)) {
                best = Math.max(best??0, v);
              } else if (v && typeof v === 'object') {
                stack.push(v);
              }
            }
          }
        }catch{}
        return best;
      }
      if (next) {
        try{
          const j = JSON.parse(next);
          const found = scanLikes(j);
          if (typeof found === 'number' && Number.isFinite(found)) likes = found;
        }catch{}
      }
      if (likes == null) {
        // 生HTML正規表現フォールバック
        const m = html.match(/"(?:like_count|likedCount|likes_count)"\s*:\s*(\d+)/i);
        if (m) likes = Number(m[1]);
      }

      return {
        tags: [...tags],
        likes: Number.isFinite(likes) ? likes : null
      };
    }catch(e){
      dbg.push(`zenn enrich err: ${String(e).slice(0,160)}`);
      return { tags: [], likes: null };
    }
  }

  async function runZenn(dom){
    const dbg = [];
    try{
      dom.list.innerHTML=""; dom.status.textContent = "読み込み中…";

      let xml = null;
      // プロキシ優先（CORS/403回避）
      if (PROXY_BASE) {
        try{
          const p = await proxyFetch(ZENN_FEED, {
            accept:"application/atom+xml,application/rss+xml,application/xml;q=0.9,*/*;q=0.7"
          });
          dbg.push(`zenn proxy status=${p.status}`);
          xml = await p.text();
        }catch(e){ dbg.push("zenn proxy failed: " + e); }
      }
      // フォールバック直取り
      if (!xml) {
        const r = await fetch(ZENN_FEED, { headers:{ Accept:"application/xml" } });
        if (!r.ok) throw new Error("direct " + r.status);
        xml = await r.text(); dbg.push("zenn direct ok");
      }

      const { feedUpdated, items } = parseZennFeed(xml);
      dom.meta.textContent = feedUpdated ? "RSS更新: " + (fmtMDHM(feedUpdated) || "取得不可") : "RSS更新: 取得不可";

      // まず行を作る（like/tags は“取得中”）。並行で enrich → 更新。
      const targets = items.slice(0,MAX);
      const rows = [];
      let rank=1;
      for (const it of targets){
        const tShown = (it.tags||[]).slice(0,2).join(", ");
        const tRest  = (it.tags||[]).length>2 ? ` 他:${(it.tags||[]).length-2}` : "";
        const li = addRow(dom.list, rank, it.link, it.title,
                          `いいね: 取得中`, (it.tags?.length?`タグ: ${tShown}${tRest}`:"タグ: 取得中"),
                          dom.brand);
        rows.push({ li, link: it.link });
        rank++;
      }
      dom.status.textContent = dom.list.children.length ? "" : "記事が見つかりませんでした。";

      // enrich（直列でも5件なら十分速い。API負荷を抑えるなら直列のまま）
      for (const row of rows){
        try{
          const info = await enrichZennFromPage(row.link, dbg);
          const likeText = `いいね: ${Number.isFinite(info.likes)?info.likes:"—"}`;
          const tags = info.tags || [];
          const shown = tags.slice(0,2).join(", ");
          const rest  = tags.length>2 ? ` 他:${tags.length-2}` : "";
          const tagText = tags.length ? `タグ: ${shown}${rest}` : "タグ: —";
          updateRow(row.li, likeText, tagText);
        }catch{}
      }
    }catch(e){
      dom.status.classList.add("error");
      dom.status.textContent = "取得に失敗しました。";
      dbg.push(`zenn error: ${String(e).slice(0,200)}`);
    }
    if (DEBUG) dom.debug.textContent = dbg.join("\n");
  }

  /* ===== はてな（トグル + 日付フォールバック） ===== */
  function parseHatenaRSS(xml){
    const doc = new DOMParser().parseFromString(xml,"application/xml");
    const NS_HATENA = "http://www.hatena.ne.jp/info/xmlns#";
    const NS_DC     = "http://purl.org/dc/elements/1.1/";

    const ch = doc.getElementsByTagName("channel")[0];
    let lastBuild =
      ch?.getElementsByTagName("lastBuildDate")[0]?.textContent?.trim() ||
      ch?.getElementsByTagName("pubDate")[0]?.textContent?.trim() || "";

    const items = [...doc.getElementsByTagName("item")].map(n=>{
      const title = n.getElementsByTagName("title")[0]?.textContent?.trim() || "(no title)";
      const link  = n.getElementsByTagName("link")[0]?.textContent?.trim()  || "";
      let bc = NaN;
      const bcSel = n.querySelector('hatena\\:bookmarkcount');
      if (bcSel) bc = Number(bcSel.textContent);
      if (!Number.isFinite(bc)) {
        const bcNs = n.getElementsByTagNameNS(NS_HATENA, "bookmarkcount")[0];
        if (bcNs) bc = Number(bcNs.textContent);
      }
      if (!Number.isFinite(bc)) bc = 0;
      const tags = [];
      const cats = n.getElementsByTagName("category");
      for (let i=0;i<cats.length;i++){ const t = cats[i].textContent.trim(); if (t) tags.push(t); }
      const dcSubs = n.getElementsByTagNameNS(NS_DC, "subject");
      for (let i=0;i<dcSubs.length;i++){ const t = dcSubs[i].textContent.trim(); if (t) tags.push(t); }
      const itemPub = n.getElementsByTagName("pubDate")[0]?.textContent?.trim() || "";
      const itemDc  = n.getElementsByTagNameNS(NS_DC, "date")[0]?.textContent?.trim() || "";
      return { title, link, bookmarks: bc, tags, _pub: itemPub || itemDc };
    });

    if (!lastBuild) {
      let bestTs = -1, bestRaw = "";
      for (const it of items){
        const ts = Date.parse(it._pub);
        if (!Number.isNaN(ts) && ts > bestTs){ bestTs = ts; bestRaw = it._pub; }
      }
      if (bestRaw) lastBuild = bestRaw;
    }
    for (const it of items) delete it._pub;
    return { lastBuild, items };
  }

  function hatenaFeedsFor(category){
    if (category === "it") return [HATENA_IT_1, HATENA_IT_2];
    return [HATENA_RSS_1, HATENA_RSS_2];
  }

  async function runHatena(dom, category="general"){
    const dbg = [];
    try{
      dom.list.innerHTML="";
      dom.status.textContent = "読み込み中…";
      const [RSS1, RSS2] = hatenaFeedsFor(category);

      let xml = null;

      // 1) 直取り
      if (HATENA_MODE === "auto" || HATENA_MODE === "direct") {
        try {
          const r1 = await fetch(RSS1, { headers: { Accept: "application/xml" } });
          if (!r1.ok) throw new Error("direct #1 " + r1.status);
          xml = await r1.text(); dbg.push(`hatena(${category}) direct #1 ok`);
        } catch(e1){
          try {
            const r2 = await fetch(RSS2, { headers: { Accept: "application/xml" } });
            if (!r2.ok) throw new Error("direct #2 " + r2.status);
            xml = await r2.text(); dbg.push(`hatena(${category}) direct #2 ok`);
          } catch(e2){
            dbg.push(`hatena(${category}) direct failed: ` + e2);
            if (HATENA_MODE === "direct") throw e2;
          }
        }
      }

      // 2) プロキシ
      if (!xml && (HATENA_MODE === "auto" || HATENA_MODE === "proxy")) {
        if (!PROXY_BASE) throw new Error("proxy_base not configured for hatena");
        let p = await proxyFetch(RSS1, { accept: "application/rss+xml,application/xml;q=0.9,*/*;q=0.7" });
        dbg.push(`hatena(${category}) proxy #1 status=${p.status}`);
        if (!p.ok) {
          p = await proxyFetch(RSS2, { accept: "application/rss+xml,application/xml;q=0.9,*/*;q=0.7" });
          dbg.push(`hatena(${category}) proxy #2 status=${p.status}`);
          if (!p.ok) throw new Error(`hatena(${category}) proxy failed (${p.status})`);
        }
        xml = await p.text();
      }

      const { lastBuild, items } = parseHatenaRSS(xml);
      dom.meta.textContent = lastBuild
        ? "RSS更新: " + (fmtMDHM(lastBuild) || "取得不可")
        : "RSS更新: 取得不可";

      const top = items.sort((a,b)=> (b.bookmarks||0) - (a.bookmarks||0)).slice(0,MAX);

      dom.list.innerHTML="";
      let rank=1;
      for (const it of top){
        const tags = it.tags || [];
        const tShown = tags.slice(0,2).join(", ");
        const tRest  = tags.length>2 ? ` 他:${tags.length-2}` : "";
        addRow(dom.list, rank, it.link, it.title,
               `ブクマ: ${Number.isFinite(it.bookmarks)?it.bookmarks:0}`,
               tags.length?`タグ: ${tShown}${tRest}`:"タグ: —",
               dom.brand);
        rank++;
      }
      dom.status.textContent = top.length ? "" : "記事が見つかりませんでした。";
    }catch(e){
      dom.status.classList.add("error");
      dom.status.textContent = "取得に失敗しました。";
      dbg.push(`hatena(${category}) error: ${String(e).slice(0,200)}`);
    }
    if (DEBUG) dom.debug.textContent = dbg.join("\n");
  }

  /* ===== はてな：右上トグル（小型） ===== */
  function setupHatenaControls(dom){
    const ctrls = dom.ctrls;
    if (!ctrls) return;

    const btnGeneral = document.createElement("button");
    btnGeneral.className = "btn";
    btnGeneral.textContent = "注目";
    btnGeneral.style.color = css("--hatena");

    const btnIT = document.createElement("button");
    btnIT.className = "btn";
    btnIT.textContent = "IT";
    btnIT.style.color = css("--hatena");

    ctrls.appendChild(btnGeneral);
    ctrls.appendChild(btnIT);

    let current = (HATENA_CAT === "it") ? "it" : "general";
    setActive(current);

    btnGeneral.addEventListener("click", () => {
      if (current === "general") return;
      current = "general";
      setActive(current);
      runHatena(dom, "general");
    });
    btnIT.addEventListener("click", () => {
      if (current === "it") return;
      current = "it";
      setActive(current);
      runHatena(dom, "it");
    });

    function setActive(cat){
      btnGeneral.classList.toggle("active", cat==="general");
      btnIT.classList.toggle("active", cat==="it");
      btnGeneral.style.borderColor = (cat==="general") ? dom.brand : "var(--border)";
      btnIT.style.borderColor      = (cat==="it")      ? dom.brand : "var(--border)";
    }
  }
})();
</script>
