<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Google Fit: Weight Chart</title>
<style>
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; }
  .wrap { max-width: 1200px; margin: 16px auto; padding: 0 12px; }
  .head { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
  .head h2 { margin: 8px 0; font-weight: 600; }
  .head button { font-size: 12px; padding: 4px 8px; cursor: pointer; border-radius: 6px; }
  .chart-box { position: relative; width: 100%; max-width: 100%; }
  .chart-box .ver {
    position: absolute; top: 4px; right: 6px;
    font-size: 10px; color: #0009; user-select: none; pointer-events: none;
  }
  canvas { display:block; width: 100%; height: 280px; }
</style>

<div class="wrap" id="wrap">
  <div class="head" id="head">
    <h2>Google Fit – Weight</h2>
    <button id="signIn">Sign in &amp; Fetch</button>
  </div>

  <div class="chart-box" id="box">
    <canvas id="chart"></canvas>
    <div class="ver" id="ver"></div>
  </div>
</div>

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>

<script>
  /* ===== バージョン表記（右上に極小表示） ===== */
  const DEFAULT_APP_VERSION = "0.07";

  /* ===== クエリ ===== */
  const qs = new URLSearchParams(location.search);
  const modeParam = (qs.get("mode") || "auto").toLowerCase();  // server | frontend | auto
  const endpointRaw = qs.get("endpoint") || "";
  const clientId = qs.get("client_id") || "";
  const days = Math.max(7, Math.min(3650, Number(qs.get("days") || 90)));
  const tz = qs.get("tz") || "Asia/Tokyo";
  const goalKg = qs.has("goal") ? Number(qs.get("goal")) : null;
  const yminQ = qs.has("ymin") ? Number(qs.get("ymin")) : null;
  const ymaxQ = qs.has("ymax") ? Number(qs.get("ymax")) : null;
  const wQ = qs.get("w") || "100%";        // 幅: 数値(px) or 'auto'/'100%' 等
  const hQ = Number(qs.get("h") || 280);   // 高さ(px)
  const APP_VERSION = qs.get("ver") || DEFAULT_APP_VERSION;

  // 埋め込み用トグル
  const showHeader = qs.get("header") !== "0";     // 0 で非表示
  const padPx = Number(qs.get("pad") ?? 12);       // 左右パディング（px）
  const allowScroll = qs.get("scroll") === "1";    // 1でスクロール許可（既定: 隠す）

  // 実行モード
  let activeMode = "frontend";
  if (modeParam === "server") activeMode = "server";
  else if (modeParam === "frontend") activeMode = "frontend";
  else activeMode = endpointRaw ? "server" : "frontend"; // auto

  /* ===== DOM ===== */
  const wrap = document.getElementById("wrap");
  const head = document.getElementById("head");
  const verEl = document.getElementById("ver");
  const signInBtn = document.getElementById("signIn");
  const box = document.getElementById("box");
  const canvas = document.getElementById("chart");
  const ctx2d = canvas.getContext("2d");
  verEl.textContent = `ver ${APP_VERSION}`;

  // 埋め込み向けの余白・スクロール制御
  if (!showHeader) head.style.display = "none";
  wrap.style.marginTop = showHeader ? "16px" : "0";
  wrap.style.paddingLeft = padPx + "px";
  wrap.style.paddingRight = padPx + "px";
  if (!allowScroll) {
    document.documentElement.style.overflow = "hidden";
    document.body.style.overflow = "hidden";
  }

  /* ===== サイズ（w/hクエリ対応・はみ出し防止） ===== */
  function applyCssSize() {
    // 幅
    if (/^\d+(\.\d+)?$/.test(wQ)) {
      // 数値なら px固定。ただし親幅を超えないよう max-width:100%
      box.style.width = wQ + "px";
      box.style.maxWidth = "100%";
      // 中のキャンバスは親にフィットさせる（はみ出し防止）
      canvas.style.width = "100%";
    } else {
      // '100%' など
      box.style.width = "100%";
      box.style.maxWidth = "100%";
      canvas.style.width = wQ;
    }
    // 高さ（最低120px）
    const h = Math.max(120, Math.floor(hQ));
    canvas.style.height = h + "px";
  }

  /* ===== Chart.js 安定化（Notion対策） ===== */
  Chart.defaults.responsive = false;      // リサイズ監視を止める
  Chart.defaults.devicePixelRatio = 1;    // DPR固定で再レイアウト抑制
  Chart.register(window['chartjs-plugin-annotation']);

  // CSSサイズ確定後に物理解像度を固定
  function fixCanvasPixelSize() {
    const cssWidth = Math.max(200, Math.floor(canvas.getBoundingClientRect().width));
    const cssHeight = Math.max(120, Math.floor(canvas.getBoundingClientRect().height));
    canvas.width = cssWidth;
    canvas.height = cssHeight;
  }

  /* ===== Y軸レンジ ===== */
  function yRangeFrom(valuesKg, goalKg){
    const nums = valuesKg.filter(v => Number.isFinite(v));
    let minAuto, maxAuto;
    if (nums.length) {
      const minVal = Math.min(...nums), maxVal = Math.max(...nums);
      minAuto = Number.isFinite(goalKg) ? (goalKg - 1) : (minVal - 1);
      maxAuto = maxVal + 1;
    } else if (Number.isFinite(goalKg)) {
      minAuto = goalKg - 1; maxAuto = goalKg + 1;
    }
    let min = Number.isFinite(yminQ) ? yminQ : minAuto;
    let max = Number.isFinite(ymaxQ) ? ymaxQ : maxAuto;
    if (Number.isFinite(min) && Number.isFinite(max) && min >= max) max = min + 1;
    return { min, max };
  }

  /* ===== 今日の目盛りを必ず表示（安全版プラグイン） ===== */
  const todayTickPlugin = {
    id: "todayTick",
    afterBuildTicks(scale) {
      try {
        if (!scale || scale.id !== "x") return;
        const ticks = Array.isArray(scale.ticks) ? scale.ticks : [];
        const now = new Date();
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        const hasToday = ticks.some(t => typeof t?.value === "number" && t.value === todayStart);
        if (!hasToday) {
          ticks.push({ value: todayStart, major: true });
          ticks.sort((a,b)=>a.value - b.value);
          scale.ticks = ticks;
        }
      } catch (e) {
        console.warn("[todayTick] plugin error:", e);
      }
    }
  };
  Chart.register(todayTickPlugin);

  /* ===== ツールチップ：日付/時刻/体重の3行フォーマット ===== */
  function fmtDateTime(ms, tz){
    const base = tz && tz !== "system" ? { timeZone: tz } : {};
    const d = new Date(ms);
    const y = d.toLocaleString("ja-JP", { ...base, year: "numeric" });
    const m = d.toLocaleString("ja-JP", { ...base, month: "2-digit" });
    const day = d.toLocaleString("ja-JP", { ...base, day: "2-digit" });
    const hh = d.toLocaleString("ja-JP", { ...base, hour: "2-digit", hour12: false });
    const mm = d.toLocaleString("ja-JP", { ...base, minute: "2-digit" });
    const ss = d.toLocaleString("ja-JP", { ...base, second: "2-digit" });
    return { dateStr: `${y}/${m}/${day}`, timeStr: `${hh}:${mm}:${ss}` };
  }

  /* ===== 描画 ===== */
  let chart = null;
  function renderChart(points){ // points: [{t(ms), kg}]
    const dates = points.map(p => new Date(p.t));
    const valuesKg = points.map(p => p.kg);
    const range = yRangeFrom(valuesKg, goalKg);

    if (chart) { chart.destroy(); chart = null; }
    chart = new Chart(ctx2d, {
      type: "line",
      data: {
        labels: dates,
        datasets: [{
          data: valuesKg,
          spanGaps: true,
          pointRadius: 2,
          borderWidth: 2,
          tension: 0.2
        }]
      },
      options: {
        responsive: false,
        animation: false,
        maintainAspectRatio: false,
        events: ["mousemove","mouseout"],
        interaction: { mode: "nearest", intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            enabled: true,
            callbacks: {
              title(items){
                if (!items?.length) return "";
                const ms = items[0].parsed.x;
                const { dateStr, timeStr } = fmtDateTime(ms, tz);
                // タイトルを2行返す
                return [dateStr, timeStr];
              },
              label(ctx){
                const v = ctx.parsed.y;
                return Number.isFinite(v) ? `${v.toFixed(2)}kg` : "-";
              }
            }
          },
          annotation: Number.isFinite(goalKg) ? {
            annotations: {
              goalLine: {
                type: 'line',
                yMin: goalKg, yMax: goalKg,
                borderColor: 'red',
                borderWidth: 2,
                borderDash: [6, 4]
              }
            }
          } : {}
        },
        scales: {
          x: {
            type: "time",
            time: { unit: "day", displayFormats: { day: "MM/dd" } },
            ticks: { autoSkip: true, maxRotation: 0 }
          },
          y: { beginAtZero: false, min: range.min, max: range.max }
        }
      }
    });
  }

  /* ===== データ取得 ===== */
  function buildEndpointUrl(raw){
    try { return new URL(raw); }
    catch(_){ try { return new URL(decodeURIComponent(raw)); } catch(e){ throw e; } }
  }

  async function fetchFromEndpoint(){
    const u = buildEndpointUrl(endpointRaw);
    u.searchParams.set("days", String(days));
    const r = await fetch(u.toString(), { cache: "no-store" });
    if (!r.ok) throw new Error(`Endpoint error ${r.status}`);
    const j = await r.json();
    return j.points || [];
  }

  const SCOPES = "https://www.googleapis.com/auth/fitness.body.read";
  let accessToken = null, tokenClient = null;

  function readyGIS(){
    return new Promise(r=>{
      const i = setInterval(()=>{ if (window.google?.accounts?.oauth2){ clearInterval(i); r(); }}, 50);
    });
  }
  async function ensureToken(){
    if (accessToken) return accessToken;
    if (!clientId) throw new Error("Missing ?client_id=");
    await readyGIS();
    return new Promise((resolve, reject)=>{
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: clientId, scope: SCOPES, prompt: "",
        callback: (resp)=> resp.error ? reject(resp) : (accessToken = resp.access_token, resolve(accessToken))
      });
      tokenClient.requestAccessToken();
    });
  }

  async function fetchFromFit(){
    const now = Date.now(), start = now - days*86400000;
    const body = {
      aggregateBy: [{ dataSourceId: "derived:com.google.weight:com.google.android.gms:merge_weight" }],
      bucketByTime: { durationMillis: 86400000 },
      startTimeMillis: start, endTimeMillis: now
    };
    const res = await fetch("https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate", {
      method: "POST",
      headers: { "Authorization": `Bearer ${accessToken}`, "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (!res.ok) throw new Error(`Fitness API error ${res.status}`);
    const json = await res.json();
    return (json.bucket||[]).map(b=>{
      const endMs = Number(b.endTimeMillis);
      const ds = b.dataset?.[0]; let kg = null;
      if (ds?.point?.length){ const p = ds.point[ds.point.length-1]; kg = p.value?.[0]?.fpVal ?? null; }
      return { t: endMs, kg };
    });
  }

  /* ===== 実行 ===== */
  async function run(){
    try{
      applyCssSize();
      requestAnimationFrame(()=>{
        fixCanvasPixelSize();
        (async ()=>{
          if (activeMode === "server") {
            signInBtn.style.display = "none";
            const points = await fetchFromEndpoint();
            renderChart(points);
          } else {
            signInBtn.style.display = ""; // 小さめ（CSS）
            await ensureToken();
            const points = await fetchFromFit();
            renderChart(points);
          }
        })().catch(e => alert(e.message || String(e)));
      });
    }catch(e){
      alert(e.message || String(e));
    }
  }

  window.addEventListener("load", run);
  signInBtn.onclick = run;
</script>
