<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Google Fit: Weight Chart</title>
<style>
  html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; }
  .wrap { max-width: 1200px; margin: 16px auto; padding: 0 12px; }
  .head { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
  .head h2 { margin: 8px 0; font-weight: 600; }
  /* 小さめボタン */
  .head button { font-size: 12px; padding: 4px 8px; cursor: pointer; border-radius: 6px; }
  /* キャンバスを包む箱（右上にverを重ねる） */
  .chart-box { position: relative; }
  .chart-box .ver {
    position: absolute; top: 4px; right: 6px;
    font-size: 10px; color: #0009; user-select: none; pointer-events: none;
  }
  /* 初期サイズ（w/hクエリでJSから上書き） */
  canvas { display:block; width: 100%; height: 280px; }
</style>

<div class="wrap">
  <div class="head">
    <h2>Google Fit – Weight</h2>
    <button id="signIn">Sign in &amp; Fetch</button>
  </div>

  <div class="chart-box" id="box">
    <canvas id="chart"></canvas>
    <div class="ver" id="ver"></div>
  </div>
</div>

<!-- Frontend OAuth（frontendモード時のみ使用） -->
<script src="https://accounts.google.com/gsi/client" async defer></script>
<!-- Chart.js + 時間軸アダプタ + annotation -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>

<script>
  /* ===== 表示バージョン（?ver= で上書き可能） ===== */
  const DEFAULT_APP_VERSION = "0.05";

  /* ===== クエリ ===== */
  const qs = new URLSearchParams(location.search);
  const modeParam = (qs.get("mode") || "auto").toLowerCase();  // server | frontend | auto
  const endpointRaw = qs.get("endpoint") || "";
  const clientId = qs.get("client_id") || "";
  const days = Math.max(7, Math.min(3650, Number(qs.get("days") || 90)));
  const tz = qs.get("tz") || "Asia/Tokyo";
  const goalKg = qs.has("goal") ? Number(qs.get("goal")) : null;
  const yminQ = qs.has("ymin") ? Number(qs.get("ymin")) : null;
  const ymaxQ = qs.has("ymax") ? Number(qs.get("ymax")) : null;
  const wQ = qs.get("w") || "100%";        // 幅: 数値(px) or 'auto'/'100%' 等
  const hQ = Number(qs.get("h") || 280);   // 高さ(px)
  const APP_VERSION = qs.get("ver") || DEFAULT_APP_VERSION;

  // 実行モード決定
  let activeMode = "frontend";
  if (modeParam === "server") activeMode = "server";
  else if (modeParam === "frontend") activeMode = "frontend";
  else activeMode = endpointRaw ? "server" : "frontend"; // auto

  /* ===== DOM ===== */
  const box = document.getElementById("box");
  const verEl = document.getElementById("ver");
  const signInBtn = document.getElementById("signIn");
  const canvas = document.getElementById("chart");
  const ctx2d = canvas.getContext("2d");
  verEl.textContent = `ver ${APP_VERSION}`;

  /* ===== サイズ（w/hクエリ対応） ===== */
  function applyCssSize() {
    // 幅
    if (/^\d+(\.\d+)?$/.test(wQ)) {
      box.style.width = wQ + "px";
      canvas.style.width = wQ + "px";
    } else {
      box.style.width = '100%';
      canvas.style.width = wQ; // '100%' など
    }
    // 高さ（最低120px）
    const h = Math.max(120, Math.floor(hQ));
    canvas.style.height = h + "px";
  }

  /* ===== Chart.js 安定化（Notion対策） ===== */
  Chart.defaults.responsive = false;      // リサイズ監視を止める
  Chart.defaults.devicePixelRatio = 1;    // DPR固定で再レイアウト抑制
  Chart.register(window['chartjs-plugin-annotation']);

  // CSSサイズ確定後に物理解像度を固定
  function fixCanvasPixelSize() {
    const cssWidth = Math.max(200, Math.floor(canvas.getBoundingClientRect().width));
    const cssHeight = Math.max(120, Math.floor(canvas.getBoundingClientRect().height));
    canvas.width = cssWidth;
    canvas.height = cssHeight;
  }

  /* ===== Y軸レンジ =====
     既定: min = (goalあり) ? goal-1 : データ最小-1
           max = データ最大+1
     クエリ ymin/ymax があれば優先
  */
  function yRangeFrom(valuesKg, goalKg){
    const nums = valuesKg.filter(v => Number.isFinite(v));
    let minAuto, maxAuto;
    if (nums.length) {
      const minVal = Math.min(...nums), maxVal = Math.max(...nums);
      minAuto = Number.isFinite(goalKg) ? (goalKg - 1) : (minVal - 1);
      maxAuto = maxVal + 1;
    } else if (Number.isFinite(goalKg)) {
      minAuto = goalKg - 1; maxAuto = goalKg + 1;
    }
    let min = Number.isFinite(yminQ) ? yminQ : minAuto;
    let max = Number.isFinite(ymaxQ) ? ymaxQ : maxAuto;
    if (Number.isFinite(min) && Number.isFinite(max) && min >= max) max = min + 1;
    return { min, max };
  }

  /* ===== “今日の目盛りを必ず表示”プラグイン（安全版） ===== */
  const todayTickPlugin = {
    id: "todayTick",
    afterBuildTicks(scale) {
      try {
        if (!scale || scale.id !== "x") return;
        const ticks = Array.isArray(scale.ticks) ? scale.ticks : [];
        const now = new Date();
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        const hasToday = ticks.some(t => typeof t?.value === "number" && t.value === todayStart);
        if (!hasToday) {
          ticks.push({ value: todayStart, major: true });
          ticks.sort((a,b)=>a.value - b.value);
          scale.ticks = ticks; // 反映
        }
      } catch (e) {
        console.warn("[todayTick] plugin error:", e);
      }
    }
  };
  Chart.register(todayTickPlugin);

  /* ===== 描画 ===== */
  let chart = null;
  function renderChart(points){ // points: [{t(ms), kg}]
    const dates = points.map(p => new Date(p.t));
    const valuesKg = points.map(p => p.kg);
    const range = yRangeFrom(valuesKg, goalKg);

    if (chart) { chart.destroy(); chart = null; }
    chart = new Chart(ctx2d, {
      type: "line",
      data: {
        labels: dates,     // Date objects
        datasets: [{
          data: valuesKg,
          spanGaps: true,
          pointRadius: 2,
          borderWidth: 2,
          tension: 0.2
        }]
      },
      options: {
        responsive: false,
        animation: false,
        maintainAspectRatio: false,
        // ホバーは有効化（暴走抑止のためイベントは最小限）
        events: ["mousemove","mouseout"],
        interaction: { mode: "nearest", intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            enabled: true,
            callbacks: {
              label(ctx){
                const ms = ctx.parsed.x, v = ctx.parsed.y;
                const d = new Date(ms);
                const opt = { year:"numeric", month:"2-digit", day:"2-digit" };
                const dateStr = (tz && tz !== "system")
                  ? d.toLocaleDateString("ja-JP", { timeZone: tz, ...opt })
                  : d.toLocaleDateString("ja-JP", opt);
                return `${dateStr} ${Number.isFinite(v) ? v.toFixed(2) + "kg" : "-"}`;
              },
              title(){ return ""; }
            }
          },
          annotation: Number.isFinite(goalKg) ? {
            annotations: {
              goalLine: {
                type: 'line',
                yMin: goalKg, yMax: goalKg,
                borderColor: 'red',
                borderWidth: 2,
                borderDash: [6, 4]
              }
            }
          } : {}
        },
        scales: {
          x: {
            type: "time",
            time: {
              unit: "day",
              displayFormats: { day: "MM/dd" } // ラベルは MM/DD
            },
            ticks: {
              autoSkip: true,
              maxRotation: 0
              // 今日の追加はプラグイン側で実施（重複しない限り他は自動）
            }
          },
          y: { beginAtZero: false, min: range.min, max: range.max }
        }
      }
    });
  }

  /* ===== データ取得 ===== */
  function buildEndpointUrl(raw){
    try { return new URL(raw); }
    catch(_){ try { return new URL(decodeURIComponent(raw)); } catch(e){ throw e; } }
  }

  async function fetchFromEndpoint(){
    const u = buildEndpointUrl(endpointRaw);
    u.searchParams.set("days", String(days));
    const r = await fetch(u.toString(), { cache: "no-store" });
    if (!r.ok) throw new Error(`Endpoint error ${r.status}`);
    const j = await r.json(); // { points: [{t,kg}, ...] }
    return j.points || [];
  }

  const SCOPES = "https://www.googleapis.com/auth/fitness.body.read";
  let accessToken = null, tokenClient = null;

  function readyGIS(){
    return new Promise(r=>{
      const i = setInterval(()=>{ if (window.google?.accounts?.oauth2){ clearInterval(i); r(); }}, 50);
    });
  }
  async function ensureToken(){
    if (accessToken) return accessToken;
    if (!clientId) throw new Error("Missing ?client_id=");
    await readyGIS();
    return new Promise((resolve, reject)=>{
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: clientId, scope: SCOPES, prompt: "",
        callback: (resp)=> resp.error ? reject(resp) : (accessToken = resp.access_token, resolve(accessToken))
      });
      tokenClient.requestAccessToken(); // ※ Notion埋め込みでは弾かれやすい
    });
  }

  async function fetchFromFit(){
    const now = Date.now(), start = now - days*86400000;
    const body = {
      aggregateBy: [{ dataSourceId: "derived:com.google.weight:com.google.android.gms:merge_weight" }],
      bucketByTime: { durationMillis: 86400000 },
      startTimeMillis: start, endTimeMillis: now
    };
    const res = await fetch("https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate", {
      method: "POST",
      headers: { "Authorization": `Bearer ${accessToken}`, "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (!res.ok) throw new Error(`Fitness API error ${res.status}`);
    const json = await res.json();
    return (json.bucket||[]).map(b=>{
      const endMs = Number(b.endTimeMillis);
      const ds = b.dataset?.[0]; let kg = null;
      if (ds?.point?.length){ const p = ds.point[ds.point.length-1]; kg = p.value?.[0]?.fpVal ?? null; }
      return { t: endMs, kg };
    });
  }

  /* ===== 実行 ===== */
  async function run(){
    try{
      applyCssSize();
      // レイアウト適用→次フレームでピクセルサイズ確定→描画
      requestAnimationFrame(()=>{
        fixCanvasPixelSize();
        (async ()=>{
          if (activeMode === "server") {
            signInBtn.style.display = "none";
            const points = await fetchFromEndpoint();
            renderChart(points);
          } else {
            signInBtn.style.display = ""; // 小さめ（CSS）
            await ensureToken();
            const points = await fetchFromFit();
            renderChart(points);
          }
        })().catch(e => alert(e.message || String(e)));
      });
    }catch(e){
      alert(e.message || String(e));
    }
  }

  window.addEventListener("load", run);
  signInBtn.onclick = run;
</script>
